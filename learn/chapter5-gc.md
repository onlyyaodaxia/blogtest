垃圾回收入门篇

# 垃圾回收概述
+ 垃圾回收分为3个步骤：
  + 1 查找不再使用的对象 
  + 2 释放对象关联的内存 
  + 3 对堆内存进行压缩整理
+ 所有垃圾收集器都将堆划分了老年代（old generation/tenured generation）和新生代（young generation）。新生代又被进一步划分为不用的区段，分别被成为 eden空间和 survivor空间。
+ 采用分代机制的原因是很多对象生存时间非常短。
+ 分代机制的优势
  + 1:新生代只是堆的一部分，与处理整个堆相比，处理新生代速度更快。（这是一种权衡，更短的停顿同时更频繁）
  + 2:新生代对象的分配方式达到了压缩整理的效果： 对象被分配在eden区，垃圾收集时，对象要么被回收，要么被移走，所有存活的对象要么被移到另一个survivor空间，要么被移到老年代。由于所有对象都被移走，相当于新生代空间在垃圾收集时自动进行了一次压缩整理。
+ 所有垃圾收集算法在新生代进行垃圾回收时都存在“时空停顿”现象。
  + 新生代是堆的一部分，对象首先在新生代分配，填满后，垃圾收集器会暂停所有应用线程，回收新生代空间。不再使用的对象会被回收，仍然使用的对象会被移动到其他地方，这个操作叫做 minor gc。
+ 不同垃圾回收算法差异最大的地方在老年代的回收。

# 4个主流垃圾收集器介绍：
+ serial收集器：
  + 常用于单cpu环境
  + full gc清理堆空间时所有应用线程暂停。
  + 相关参数设置为： -XX:+UseSerialGC进行开启（通常可以使用时默认就是开启的），没有对应堆关闭参数，关闭是通过指定其他堆垃圾收集器。
+ throughput（parallel）收集器
  + server级虚拟机的默认收集器
  + 使用多线程处理新生代和老年代的垃圾回收
  + 相关参数设置：-XX:+UseParallelGC / -XX:+UseParallelOldGC 
+ cms收集器
  + 使用多线程处理新生代和老年代垃圾回收
  + 相关参数设置：-XX:+UseParNewGC (新生代收集配置) -XX:+UseConcMarkSweepGC
  + full gc时不再暂停应用线程，而是使用若干线程定期扫描老年代空间，即时回收。
  + 优点是低延迟，后台线程扫描老年代时发生及其短暂的停顿。
  + 缺点有两个 1是后台扫描线程会占用更高的cpu使用。 2是后台线程不进行压缩整理，产生碎片
  + 如果后台线程无法获得完成任务需要的cpu资源，或者过度碎片化，cms会退化到serial收集器的行为：暂停应用线程，使用单线程回收，整理老年代空间。 这之后又恢复到并行。
+ g1收集器
  + g1设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。
  + 参数设置： -XX:+UseG1GC
  + 相比cms，g1在老年代进行了分区，后台线程扫描时将对象从一个区域移到另一个区域，相当于进行了简单的整理，所以它更不容易产生碎片。
+ 收集器选择
  + 在throughput和concurrent收集器之间选择的依据主要是有多少空闲cpu资源能用于后台的并发线程。 cpu资源充足可以选择 concurrent收集器。
  + concurrent收集器之间选择的依据是堆大小，如果堆较小，推荐cms  

# gc调优基础
调整堆大小
* 设置太小，程序可能大部分时间在gc。
* 设置太大，程序停顿的频率虽然可以降低，但是停顿的时间更长。
* 超大堆的另一个风险在于操作系统使用虚拟内存机制管理物理内存，如果jvm分配了超过物理内存大小的堆，可能发生磁盘内存交换
* 堆大小调整第一原则：不要将堆容量设置堆比物理内存大。 并且还需要为jvm自身和机器上其他应用预留一部分内存，通常普通操作系统需要预留1GB内存空间
* 堆大小的默认值取决于多个因素（操作系统类型、内存大小等）  
  * 64位linux机器，初始值是min（512mb，物理内存大小的1/64）
  * 64位linux机器，最大值是min（32gb，物理内存大小的1/4）
* 堆大小调整： 初始值： -xms N    最大值： -xmx N
* 堆大小查看：jinfo -flags 47                                      
* 堆大小设置的一个经验法则：full gc后应该释放70%的空间（可以用jconsle连接应用程序进行强制full gc）
* 最佳实践？

代空间调整：
* 新生代设置较大，垃圾收集的频率就比较低，老年代比较容易被填满，会更频繁地触发fullgc
* 代大小调整（都是调整新生代空间，剩余堆空间被老年代占用）
  * -XX:NewRatio=N   新生代/老年代比率，默认值 2
  * -XX:NewSize=N 新生代初始大小，默认初始堆大小/（1+NewRatio）
  * -XX:MaxNewSize=N 新生代最大大小
  * -XmnN 将新生代初始大小和最大大小设置为同一个值的快捷方法
  * 最佳实践？ 

永久代和元空间
* jvm载入类的时候需要记录类的元信息。java7称为永久代（permgen），java8称为元空间
* 64位jvm，二者默认初始值都是20.75MB, 永久代默认最大值82MB，元空间默认最大值没有限制
* -XX:PermSize=N    -XX:MaxPermSize=N    永久代初始/最大值
* -XX:MetaspaceSize=N  -XX:MaxMetaspaceSize=N   元空间初始/最大值
* 查看设置：jcmd 47 VM.flags -all |grep -i meta
* 元空间默认最大值没有限制，应用可能因为元空间被填满而内存耗尽。如果限制元空间大小，应用程序也可能因为元空间耗尽oom。终极解决方案还是定位为什么元空间会变得如此巨大
* 永久代/元空间从初始值到最大值的调整过程会触发fullgc，程序启动时发生大量fullgc通常是由于加载巨量的类导致元空间大小调整。 这种情况建议增大初始值。

控制并发
* -XX:ParallelGCThreads=N
* 默认线程数是根据cpu算出来的  并发线程数= 8+（（N-8）*5/8）

垃圾回收工具-gc日志
* gc日志默认关闭，开启gc日志： -verbose:gc (等价于 -XX:+PrintGC) ，-XX:+PrintGCDetails
* -XX:+PrintGCTimeStamps       -XX:+PrintGCDateStamps 打印时间戳
* -Xloggc:filename  日志文件输出地址，默认是标准输出
* -XX:UseGCLogfileRotation  -XX:NumberOfGCLogfiles=N  -XX:GCLogfileSize=N 控制日志循环
* gc文件分析工具：GC Histogram   / jconsole /jstat -gcutil 47 1000


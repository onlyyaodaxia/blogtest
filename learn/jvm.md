抄录， 原文忘了在哪里了，侵 删

# JVM 深入理解JAVA虚拟机

## 一、类加载器

- 类型的加载、连接与初始化过程都是在程序运行期间完成的。

1、Java虚拟机的生命周期：

- 执行力System.exit()
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致虚拟机进程终止

2、三个阶段

加载：查找并加载类的二进制数据

连接：

- 验证：确保被加载的类的正确性。
- 准备：为类的**静态变量**分配内存，并将其初始化为**默认值**
- 解析：**把类中的符号引用（间接引用）转换为直接引用（指针直接引用）**

**初始化：为类的静态变量赋予正确的初始值。**

class Test{ 

​	public static int a =1;

}

准备阶段，把int的默认值（0）赋给a；在初始化阶段，把类的静态变量赋予正确的初始值——1赋给a；

3、类的使用与卸载

卸载：将类从内存中销毁调。如（OSTI）

主动使用（七种）

1. 创建类的实例

2. 访问某个类或者接口的静态变量，或者对该静态变量赋值

3. 调用类的静态方法（ 助记符）

4. 反射

5. 初始化一个类的子类

6. Java虚拟机启动时被标明为启动类的类（Java Test）

7. JDK1.7开始提供的动态语言支持：java.lang.invoke.MethoHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化。

除了以上七种，其他都是被动使用，都不会导致类的初始化。

### 类的加载

​        **类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个Class对象用来封装类在方法区内的数据结构。**

### JVM参数

-XX：+<option>，表示开启option选项

-XX：-<option>，表示关闭option选项

-XX：<option>=<value>,表示将option选项的值设置为value



- 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。  
- 如果一个常量的值在编译期间无法确定，则不会放到调用类的常量池中，这是在程序运行时，会导致主动使用这个常量所在的类，进行初始化。
- 助记符
- - ldc：表示将int，float或是String类型的常量值从常量池中推送至栈顶。
  - bipush表示将单字节（-128~127）的常量值推送至栈顶。
  - sipush表示将短整型常量值（-32768~32767）推送至栈顶
  - iconst_1表示将int类型的1推送至栈顶。-101 2345类推，6就不是了。
  - anewarray：表示创建一个引用类型的（类、接口、数组）数组，并将其引用值压入栈顶。
  - newarray：表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶。
- 对于数组实例来说，类型是JVM在运行期动态生成的，动态生成的类型，其父类型就是Object。
- 对于数组来说，JavaDoc经常将构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。
- 当一个接口在初始化时，并不要求其父接口都完成了初始化。只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化

![image-20200316184453256](https://tva1.sinaimg.cn/large/00831rSTly1gd8o06t2s1j30or0iuwl8.jpg)

## 类的加载

两种类加载器

1.Java虚拟机自带的加载器

- 根类加载器（Bootstrap）
- 扩展类加载器（Extension）
- 系统（应用）类加载器（System）

2.用户自定义的类加载器

- java.lang.ClassLoader的子类
- 用户可以定制类的加载方法

类加载器并不需要等到某个类被“首次主动使用”时再加载它。

![image-20200316185229583](https://tva1.sinaimg.cn/large/00831rSTly1gd8o09ooyrj30iu0cc46h.jpg)

## 类的验证：

类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。

内容：

- 类文件的结构检查
- 语义检查
- 字节码验证
- 二进制兼容性的验证

在准备阶段，会为类的静态变量分配内存，并设置默认的初始值。

初始化阶段，执行类的初始化语句，为类的静态变量赋予初始值。静态变量初始化有两种途径：1、在静态变量的声明处进行初始化；2、在静态代码块中进行初始化。 

静态变量的声明语句以及静态代码块都被看做类的初始化语句，会按照初始化语句在类中的顺序来依次执行。

## 类的初始化步骤

- 假如类还没有加载和连接，就先进行加载和连接
- 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句。 

一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。

类的初始化时机：

- 只有当程序访问的静态变量或静态方法确实在当前类或者接口中定义时，才可以任务是对类或者接口的主动使用。

- 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

![image-20200316190244745](https://tva1.sinaimg.cn/large/00831rSTly1gd8o075yiej30h4052dhp.jpg)

![image-20200316190413221](https://tva1.sinaimg.cn/large/00831rSTly1gd8o0961emj30fs0a2adx.jpg)

当一个接口在初始化时，并不要求其父接口都完成了初始化。只有在真正使用到父接口的时候（如引用接口所定义的常量时），才会初始化

当一个类被初始化时，并不会初始化他的接口。

调用Classloader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化，而反射可以。

 数组类的class对象不是由classLoader创建的，是运行时由JVM自动创建的。

数组类返回的加载器和数组类里元素的加载器是一样的。

通过defineClass方法把二进制数组赋值给类来生成类对象。

![image-20200318191930251](https://tva1.sinaimg.cn/large/00831rSTly1gd8o0a75i2j30we0aate9.jpg)

自定义类加载如果加载的是应用内的类，会被委托给父类加载器（应用加载器）所加载。

不同的类加载器实例代表不同的命名空间，可以分别加载相同名称的类。同一个命名空间只会加载一个相同名称的类

![image-20200319225249725](https://tva1.sinaimg.cn/large/00831rSTly1gd8o07qjthj30id0cr7c8.jpg)

### 类的卸载

![image-20200319222752236](https://tva1.sinaimg.cn/large/00831rSTly1gd8o06do80j30hf03yjst.jpg)

由用户自定义的类加载器所加载的 类是可以被卸载的。



不同类加载器加载的类属于不同的命名空间，父类命名空间不能访问子类命名空间中的类。反之则可以。 

![image-20200323233217595](https://tva1.sinaimg.cn/large/00831rSTly1gd8o08jdjbj30hb05wmz4.jpg) 

**双亲委托机制的好处：**

1.可以确保java核心库的类型安全：所有的Java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到Java虚拟机中;如果这个加载过程是由Java应用自己的类加载器所完成的，那么很可能就会在JVM中存在多个版本的java.lang.Object类，而且这个类之间还是不兼容的，互相不可见的（正是命名空间在发挥着作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动类加载器来统一完成,从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是互相兼容的。

2.可以确保Java核心类库所提供的类不会被自定义的类所替代。

3.不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中,主需要用不同的类加载器来加载他们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。 



在运行期，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。如果同样名字（即相同的完全限定名）的类是又两个不同的类加载器所加载，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载亦如此。 

在Oracle的Hotspot实现中，系统属性sun.boot.class.path如果修改错了，则运行会出错。 

内建于JVM中的启动类加载器java.lang.ClassLoader以及其他的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器（Bootstrap）

启动类加载器并不是Java类，而其他的类加载器则都是java类，启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。

所有类加载器（除了启动类加载器）都被实现为Java类，不过总要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。

启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。

扩展类加载器与系统类加载器也是由启动类加载器所加载的 

如果要自定义系统类加载器，则需要将自定义加载器实现一个带一个Classloader参数的构造函数，因为系统是由反射方法来设置自定义的系统类加载器，且会把AppClassLoader当做自定义类加载器的双亲。

每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类）如果ClassX引用了ClassY，那么ClassX的类加载器就会去加载ClassY（前提是ClassY尚未被加载）

**线程上下文类加载器**（Context ClassLoader）类Thread中的getContextClassLoader用来获取上下文类加载器。

如果没有设置上下文类加载器的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。 在线程中运行的代码可以通过该类加载器来加载类与资源。

线程上下文类加载器的重要性：

父ClassLoader可以使用当前线程Thread.currentThread().getContextLoader()所指定的classLoader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。

线程上下文类加载器就是当前线程的current ClassLoader。

在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载，但是对于SPI来说，有些接口是Java核心库所提供的，而Java核心课是又启动类加载器来加载的，而这些接口的实现却来自于不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。

![image-20200325205945467](https://tva1.sinaimg.cn/large/00831rSTly1gd8o083aahj30o108kn2b.jpg)



SPI接口的实现类的加载，通过ServiceLoader类来加载接口对应的实现类，具体声明在META-INF/services文件中。

  

